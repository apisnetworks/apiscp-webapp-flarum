<?php
	/**
	 *  +------------------------------------------------------------+
	 *  | apnscp                                                     |
	 *  +------------------------------------------------------------+
	 *  | Copyright (c) Apis Networks                                |
	 *  +------------------------------------------------------------+
	 *  | Licensed under Artistic License 2.0                        |
	 *  +------------------------------------------------------------+
	 *  | Author: Matt Saladna (msaladna@apisnetworks.com)           |
	 *  +------------------------------------------------------------+
	 */

	use Module\Support\Webapps;
	use Module\Support\Webapps\App\Type\Flarum\Handler;
	use Module\Support\Webapps\ComposerMetadata;
	use Module\Support\Webapps\ComposerWrapper;
	use Opcenter\Auth\Password;
	use Opcenter\Auth\Shadow;

	/**
	 * Flarum management
	 *
	 * @package core
	 */
	class Flarum_Module extends Laravel_Module
	{
		// remain on 20xx versions
		const DEFAULT_VERSION_LOCK = 'major';
		const PACKAGIST_NAME = 'flarum/flarum';
		const APP_NAME = Handler::NAME;
		const BINARY_NAME = 'flarum';
		const VALIDITY_FILE = self::BINARY_NAME;

		protected $aclList = array(
			'min' => array(
				'storage',
				'vendor',
				'composer.json',
				'composer.lock',
				'public/assets'
			),
			'max' => array(
				'storage/cache',
				'storage/formatter',
				'storage/less',
				'storage/locale',
				'storage/logs',
				'storage/sessions',
				'storage/tmp',
				'storage/views',
				'public/assets'
			)
		);

		public function install(string $hostname, string $path = '', array $opts = array()): bool
		{
			return parent::install($hostname, $path, $opts);
		}

		public function get_version(string $hostname, string $path = ''): ?string
		{
			return parent::get_version($hostname, $path);
		}

		public function valid(string $hostname, string $path = ''): bool
		{
			return parent::valid($hostname, $path);
		}

		public function update_all(string $hostname, string $path = '', string $version = null): bool
		{
			return parent::update_all($hostname, $path, $version);
		}

		public function update(string $hostname, string $path = '', string $version = null): bool
		{
			return parent::update($hostname, $path, $version);
		}


		protected function postInstall(string $hostname, string $path): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			$ret = $this->execPhp($approot, static::BINARY_NAME . ' install --file %s', ["{$approot}/.env"]);
			$this->file_delete("{$approot}/.env");
			if (!$ret['success']) {
				return error("Failed to finish %(name)s install: %(err)s", [
					'name' => static::APP_NAME, 'err' => coalesce($ret['stderr'], $ret['stdout'])
				]);
			}

			return $this->postUpdate($hostname, $path);
		}

		protected function postUpdate(string $hostname, string $path): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			foreach (['migrate', 'cache:clear', 'assets:publish'] as $directive) {
				$this->execPhp($approot, static::BINARY_NAME . ' ' . $directive);
			}

			return true;
		}

		protected function updateLibraryName(string $approot): string
		{
			return \Module\Support\Webapps\App\Type\Flarum\Reconfiguration\Verlock::PACKAGE_NAME;
		}

		protected function notifyInstalled(string $hostname, string $path = '', array $args = []): bool
		{
			$args['login'] ??= $args['user'];
			return parent::notifyInstalled($hostname, $path, $args);
		}

		/**
		 * Get Flarum framework versions
		 *
		 * @return array
		 */
		public function get_versions(): array
		{
			return parent::getPackagistVersions('flarum/core');
		}

		protected function parseInstallOptions(array &$options, string $hostname, string $path = ''): bool
		{
			if (!isset($options['user'])) {
				$options['user'] = $this->username;
			}
			info("setting admin user to `%s'", $options['user']);
			if (!isset($options['password'])) {
				info("autogenerated password `%s'",
					$options['password'] = Password::generate()
				);
			}

			return parent::parseInstallOptions($options, $hostname, $path);
		}

		public function uninstall_plugin(string $hostname, string $path, string $plugin, bool $force = false): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			$composer = ComposerWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot));
			if ($force && !$this->disable_plugin($hostname, $path, $plugin)) {
				return false;
			}
			$ret = $composer->exec($approot, 'remove %s', [$plugin]);

			return $ret['success'] ?: error("Failed to remove plugin: %s", coalesce($ret['stderr'], $ret['stdout']));
		}

		public function install_plugin(string $hostname, string $path, string $plugin, string $version = '*'): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			$composer = ComposerWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot));

			$ret = $composer->exec($approot, 'require %s:%s', [$plugin, $version]);

			return $ret['success'] && $this->enable_plugin($hostname, $path, $plugin) ?:
				error("Failed to install plugin: %s", coalesce($ret['stderr'], $ret['stdout']));
		}

		public function plugin_status(string $hostname, string $path = '', string $plugin = null)
		{
			$approot = $this->getAppRoot($hostname, $path);
			$pdo = Webapps::connectorFromCredentials($dbCfg = $this->db_config($hostname, $path));
			$activeExtensions = array_flip(json_decode(
				$pdo->query("SELECT REPLACE(`value`, '-', '/') AS `value` FROM `{$dbCfg['prefix']}settings` WHERE `key` = 'extensions_enabled'")->fetchObject()?->value
			));

			$meta = ComposerMetadata::readFrozen($this->getAuthContextFromDocroot($approot), $approot);
			$flarumPackages = array_filter((array)$meta->packages(),
				fn($package) =>
					isset($activeExtensions[$package['name']]) ||
					$package['name'] === $plugin ||
					$plugin === null && str_starts_with($package['name'], 'flarum/')
			);
			$pluginmeta = array_build(
				$flarumPackages,
				fn($i, $package) => [
					$package['name'],
					[
						'version' => $package['version_normalized'],
						'active'  => isset($activeExtensions[$package['name']])
					]
				],
			);

			unset($pluginmeta['flarum/core']);

			return $plugin ? $pluginmeta[$plugin] ?? error("unknown plugin `%s'", $plugin) : $pluginmeta;
		}

		/**
		 * Disable plugin
		 *
		 * @param string $hostname
		 * @param string $path
		 * @param string $plugin
		 * @return bool
		 */
		public function disable_plugin(string $hostname, string $path, string $plugin): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			$composer = ComposerWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot));
			$ret = $composer->direct($approot, self::BINARY_NAME . ' --no-ansi extension:disable %s', [
				str_replace('/', '-', $plugin)
			]);

			if (str_contains($ret['stderr'], "There are no extensions")) {
				warn($ret['stderr']);
			}
			return $ret['success'] ?: error("Unable to disable plugin %(plugin)s: %(err)s",
				['plugin' => $plugin, 'err' => coalesce($ret['stderr'], $ret['stdout'])]);
		}

		/**
		 * Enable plugin
		 *
		 * @param string $hostname
		 * @param string $path
		 * @param string $plugin
		 * @return bool
		 */
		public function enable_plugin(string $hostname, string $path, string $plugin): bool
		{
			$approot = $this->getAppRoot($hostname, $path);
			$composer = ComposerWrapper::instantiateContexted($this->getAuthContextFromDocroot($approot));
			$ret = $composer->direct($approot, self::BINARY_NAME . ' --no-ansi extension:enable %s', [str_replace('/', '-', $plugin)]);
			if (str_contains($ret['stderr'], "There are no extensions")) {
				$ret['success'] = false;
			}

			return $ret['success'] ?: error("Unable to enable plugin %(plugin)s: %(err)s",
				['plugin' => $plugin, 'err' => coalesce($ret['stderr'], $ret['stdout'])]);
		}

		protected function setConfiguration(string $approot, string $docroot, array $config)
		{
			$envcfg = (new \Opcenter\Provisioning\ConfigurationWriter('@webapp(' . $this->getAppName() . ')::templates.env',
				\Opcenter\SiteConfiguration::shallow($this->getAuthContext())))
				->compile($config);

			return $this->file_put_file_contents("{$approot}/.env", (string)$envcfg) && $this->file_chmod("{$approot}/.env", 600);
		}

		public function get_admin(string $hostname, string $path = ''): ?string
		{
			$db = $this->db_config($hostname, $path);
			$mysql = Webapps::connectorFromCredentials($db);
			$query = "SELECT username FROM {$db['prefix']}users JOIN {$db['prefix']}group_user ON ({$db['prefix']}group_user.user_id = {$db['prefix']}users.id) WHERE group_id = 1 ORDER BY {$db['prefix']}users.id DESC LIMIT 1";
			$rs = $mysql->query($query);
			return $rs->rowCount() === 1 ? $rs->fetchObject()->username : null;
		}

		/**
		 * Get database configuration for a blog
		 *
		 * @param string $hostname domain or subdomain of wp blog
		 * @param string $path     optional path
		 * @return array|bool
		 */
		public function db_config(string $hostname, string $path = '')
		{
			$this->web_purge();
			$approot = $this->getAppRoot($hostname, $path);
			if (!$approot) {
				return error('failed to determine %s', $this->getAppName());
			}

			try {
				$cfg = Webapps\App\Type\Flarum\Walker::instantiateContexted($this->getAuthContextFromDocroot($approot), ["{$approot}/config.php"])->get('database');
			} catch (\ArgumentError) {
				return error("Failed to obtain %(app)s configuration for `%(path)s'", ['app' => static::APP_NAME, 'path' => $approot]);
			}

			return [
				'type' => $cfg['driver'] ?? 'mysql',
				'host' => $cfg['host'],
				'port' => $cfg['port'],
				'db'   => $cfg['database'],
				'user' => $cfg['username'],
				'password' => $cfg['password'],
				'prefix' => $cfg['prefix']
			];
		}

		/**
		 * @param string $hostname
		 * @param string $path
		 * @param array  $fields available option: password, user, email
		 * @return bool
		 */
		public function change_admin(string $hostname, string $path, array $fields): bool
		{
			$docroot = $this->getAppRoot($hostname, $path);
			if (!$docroot) {
				return warn('failed to change administrator information');
			}
			$admin = $this->get_admin($hostname, $path);

			if (!$admin) {
				return error('cannot determine admin of install');
			}

			if (isset($fields['password'])) {
				if (!Shadow::crypted($fields['password'])) {
					if (!Password::strong($fields['password'])) {
						return error("Password is insufficient strength");
					}
					$fields['password'] = password_hash($fields['password'], CRYPT_BLOWFISH);
				} else if (!Shadow::valid_crypted($fields['password'])) {
					// error generated from fn
					return false;
				}
			}

			if (isset($fields['email']) && !preg_match(Regex::EMAIL, $fields['email'])) {
				return error("Invalid email");
			}

			if (isset($fields['user']) && !preg_match(Regex::USERNAME, $fields['user'])) {
				return error("Invalid user");
			}

			$valid = [
				'user'     => 'username',
				'email'    => 'email',
				'password' => 'password'
			];

			if ($unrecognized = array_diff_key($fields, $valid)) {
				return error("Unrecognized fields: %s", implode(array_keys($unrecognized)));
			}

			if (!$match = array_intersect_key($valid, $fields)) {
				return warn("No fields updated");
			}

			$fields = array_intersect_key($fields, $match);
			$db = $this->db_config($hostname, $path);
			$admin = $this->get_admin($hostname, $path);
			$mysql = Webapps::connectorFromCredentials($db);
			$query = "UPDATE {$db['prefix']}users SET " .
				implode(', ', array_key_map(static fn($k, $v) => $valid[$k] . ' = ' . $mysql->quote($v), $fields)) . " WHERE username = " . $mysql->quote($admin);

			$rs = $mysql->query($query);
			return $rs->rowCount() > 0 ? true : error("Failed to update admin `%(admin)s', error: %(err)s",
				['admin' => $admin, 'err' => $rs->errorInfo()]);
		}
	}